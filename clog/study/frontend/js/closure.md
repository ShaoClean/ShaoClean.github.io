---
icon: javascript
date: 2022-09-09
star: 20
category:
  - 前端
  - JS
tag:
  - 闭包
  - 学习笔记
---
# 闭包

这是MDN上的描述：

>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

也就是说：

- 闭包是在`函数创建`时创建的，所以`函数创建就会生成闭包`；
- 定义函数不会创建闭包，只有创建/执行函数同时才创建闭包；
- 闭包和其函数在`同一上下文中`
- 闭包包含该作用域下的所有变量/引用地址

## 为什么要使用闭包

首先来说一下局部变量和全局变量的危害： 全局变量容易全局污染，局部变量又无法共享，不能长久保存

## 闭包的作用

既可以共享，长久保存，又不会全局污染，其实是用来保护局部变量的。

## 闭包的缺点

占内存因为变量被内部资源占用，而JS的垃圾回收机制不会回收内部函数所占的资源

在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。

## 简单实现闭包

```js
function outer() {
  let num = 10;
  function inner() {
    console.log(num);
    debugger;
  }
  inner();
}
outer();
```

打开谷歌浏览器的调试工具，如下图：

![image-20220909163427674](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7374/image-20220909163427674.png)

`outer`函数给`inner`函数提供了闭包作用域，那么`inner`函数就是闭包函数

`Closure`指的就是闭包，可以看到在`outer`的闭包作用域中存在一个变量`num`

## 形成闭包的条件

形成闭包的必要条件就是，**闭包函数(被包裹的函数)中必须要使用到外部函数中的变量**。

应用：

1.单例设计模式

2.惰性函数:函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，下次执行的时候就执行覆盖后的函数

3.函数柯理化