---
icon: javascript
date: 2022-09-19
star: 10
category:
  - 前端
  - JS
tag:
  - 事件循环
  - 学习笔记
---

# 事件循环机制

在了解事件循环机制之前，需要了解：

- 同步任务

  在主线程上排队的任务，前一个任务执行完毕，才能继续执行下一个任务

- 异步任务

  不会立马进入主线程，而是先进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，任务才会进入主线程去执行。具体见[如何理解 JS 的异步](./js-async.html)

- 回调函数

- js 在浏览器中的执行机制

## 概述

事件循环机制是 html 提出的概念，是为了协调事件，用户交互，脚本，渲染，网络等，从整体上告诉了我们所写 JS 代码的执行顺序。

JS 的一大特点就是单线程，并没有专门的异步线程。但它也支持异步操作（暂时理解为又开了一个新的线程），这个异步操作是浏览器提供的，他会放到浏览器的循环队列里面，等待主线程栈发出命令来执行这个队列里面的事件。

在 JS 代码执行的过程中，通过函数的调用栈来决解函数的执行顺序，当然也存在另外一些特殊的状况，通过任务队列（task queue）来解决另外一些代码的执行。任务队列可以分为`宏任务(macro-task)`和`微任务(micro-task)`

## 异步任务

在上面提到了，异步任务是不会立马进入主线程的任务而是进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，任务才会进入主线程执行。异步任务又可以分为：宏任务、微任务

### 宏任务

宏任务就是所谓的主线程？

宏任务包含：script（整体代码）、setTimeout、setInterval、setImmediate、I/O、UI rendering

### 微任务

微任务包含：process.nextTick、Promise、Object.observe

:::warning 注意

Promise 和 setTimeout 等还是同步的代码，称为任务源。而进入任务队列的是他们指定的具体所要执行的任务。Promise 具体需要执行的任务例如`then`函数是微任务，而 setTimeout 中携带的任务是宏任务。无论是微任务还是宏任务的执行，都需要借助`函数调用栈`（栈内存）来完成。

宏任务与微任务的执行顺序：先执行微任务，再执行宏任务

:::


### 2023.4.8更新
面试题，下面输出的结果
```js

async function asy1(){
    console.log(1);
    await asy2()
    console.log(2);
}

async function asy2(){
    await setTimeout((_)=>{
        Promise.resolve().then((_)=>{
            console.log(3);
        })
        console.log(4);
    },0)
}

async function asy3(){
    Promise.resolve().then((_)=>{
        console.log(6);
    })
}

asy1()
console.log(7); 
asy3()

```

分析：

1. 执行函数`asy1`的同步代码

2. 输出7

3. 执行函数`asy3`的同步代码

   



细化上面的三点：

执行函数`asy1`的同步代码，`输出结果1`。

执行函数`asy2`的同步代码，0秒后将计时器中的函数加入到宏任务队列。等待函数`asy2`的执行完成后，将`输出结果2`加入到微任务队列。虽然函数`asy2`中的同步代码执行完了，但是由于`await`关键字的存在，实际上是没有执行完的，还有一个`隐形的微任务`存在，所以此时`asy2`并没有执行完成。

相当于：

```js
function asy2(){
  await new Promise((resolve)=>{
    let timer = setTimeout((_)=>{
        Promise.resolve().then((_)=>{
            console.log(3);
        })
        console.log(4);
    },0)
    resolve(timer);
  }).then((value)=>{
    //隐形的.then
    //...
  })
}

```

输出结果7。

将输出6加入到微任务队列。

至此同步代码执行完成，执行微任务队列中的代码。

执行隐形的微任务，此时函数`asy2`执行完成，将输出结果`2`加入到微任务队列。

`输出结果6`

`输出结果2`

执行宏任务队列中的任务。将输出结果3加入到微任务队列

执行同步代码，`输出结果4`

执行宏任务队列中的任务，`输出结果3`

所以最终的输出结果为：

```
1、7、6、2、4、3
```

