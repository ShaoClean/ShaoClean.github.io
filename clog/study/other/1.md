---
icon: computer
category:
  - 数据结构
tag:
  - 学习笔记
---
# 数据结构

可以分为下面三大类

- 数据的逻辑结构

  - 线性结构

    线性表、栈（特殊线性表）、队列（特殊线性表）、字符串、数组、广义表

  - 非线性结构

    树形结构、图形结构

- 数据的存储结构

  - 顺序存储
  - 链式存储

- 数据的运算

​	检索、排序、插入、删除、修改等

## 1.绪论

### 算法和算法分析

#### 算法特性
- 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷事件内完成
- 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入：一个算法有0个或多个输入
- 输出：一个算法有一个或多个输出

#### 算法设计要求
- 正确性
- 可读性
- 健壮性
- 高效性

#### 算法分析
如何衡量一个算法的好坏？
一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。
主要考虑下面两个方面：

- 时间效率：指的是算法所耗费的时间
- 空间效率：指的是算法执行过程中所耗费的存储空间

**1.算法时间效率的度量**
算法运行时间 = 一个简单操作所需的时间 * 简单操作次数 = （每条语句频度 * 该语句执行一次所需的时间）求和 

若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。
记作T(n)=O(f(n))，称O(f(n))喂算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度

<span style='color:red'>例</span>：
求`T(n) = 2n^3 + 3n^2 + 2n + 1`的时间复杂度

根据定义，需要找到一个辅助函数f(n)，当n趋近于无穷大时，使得T(n)/f(n) ～ 常数（0除外）。

因为n是趋近于无穷大的，所以可以得出T(n)的极限值为2n^3。

因此问题就变成了2n^3/f(n) ～ 常数（0除外），也就是说当n充分大的时候，T(n)的数量级为n^3，T(n)于n^3是同一个数量级的（同阶）

那么此时，易得f(n) = n^3，常数为2

所以T(n) = O(n^3)

**2.算法空间复杂度的度量**

空间复杂度：算法所需存储空间的度量（其中n为问题的规模（或大小）
$$
S(n) = O(f(n))
$$
算法要占据的空间可以是：

- 1.算法本身要占据的空间，输入\输出，指令，常数，变量等
- 2.算法要使用的辅助空间

<span style='color:red'>例</span>：

实现将数组a中的数据逆序的存放到数组b中

```javascript
//算法1
for(let i=0;i<n/2;i++){
  t = a[i];
  a[i] = a[n-i-1];
  a[n-i-1] = t;
}

//算法2
for(let i=0;i<n;i++){、
	b[i] = a[n-i-1];
}
for(let i = 0;i<n;i++){
  a[i]=b[i]
}
```

分析：

在算法一中，涉及到了一个新的中间变量来存储，且这个变量每次的存储个数固定为1。所以可以可以得到算法1中的空间复杂度为1。用公式可以表示为：
$$
S(n) = O(1)
$$
在算法二中，涉及到了一个新的数组用来转换。这个数据的长度个数为n的，所以空间复杂度为n。可以用公式表示为：
$$
S(n) = O(n)
$$

## 2.线性表

### 1.线性表的定义和特点

线性表是具有相同特性的数据元素的一个有限序列。

线性表的逻辑特征：

- 1.在非空的线性表，有且仅有一个开始节点$a_1$，它没有直接前趋，而仅有一个直接后继$a_2$；
- 2.有且仅有一个中断节点$a_n$，它没有直接后继，而仅有一个直接前趋$a_{n-1}$
- 3.其余的内部节点$a_i(2 \leq i \leq n-1)$都有且仅有一个直接前趋$a_{i-1}$和一个直接后继$a_{i+1}$

 顺序存储结构存在问题：

- 存储空间分配不灵活
- 运算的空间复杂度高

### 2.线性表的类型定义

**线性表的基本操作**

- 1.InitList(&L)

  构造一个空的线性表L

- 2.DestoryList(&L)

  线性表L存在的情况下

  销毁线性表L

- 3.ClearList(&L)

​		线性表L存在的情况下		

​		将线性表L重置为空表

- 4.ListEmpty(&L)

  线性表L存在的情况下

​	   若线性表L为空表，则返回true；否则返回false。

- 5.ListLength(&L)

​		线性表L存在的情况下

​		返回线性表L中的数据元素个数

- 6.GetElem(L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)

​		用e返回线性表L中第i个数据元素的值。

- 7.LocateElem(L,e,compare())

​		线性表L存在的情况下,compare()是数据元素判定函数

​		返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0

- 8.PriorElem(L,cur_e,&pre_e)

​		线性表L存在的情况下，cur_e表示当前元素

​		若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无意义。

- 9.NextElem(L,cur_e,&next_e)

​		线性表L存在的情况下

​		若cur_e是L的数据元素，且不是最后一个。则用next_e返回它的后继元素，否则操作失败，next_e无意义

- 10.ListInsert(&L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)+1

​		在L的第i个位置之前插入新的数据元素e，L的长度加一

- 11.ListDelete(&L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)

​		删除L的第i个数据元素，并用e返回其值，L的长度减一

- 12.ListTraverse(&L,visited())

​		线性表L存在的情况下

​		依次对线性表中每个元素调用visited()函数

以上运算操作是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于”如何做“等实现细节，只有待确定了存储结构之后才考虑

### 3.线性表的顺序表示和实现

在计算机内，线性表有两种基本的存储结构：`顺序存储结构`和`链式存储结构`

**顺序存储定义：**把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构 

所有数据元素的存储位置均可由第一个数据元素的存储位置得到：
$$
LOC(a_i) = LOC(a_1) + (i-1)\times l
$$
