---
icon: edit
date: 2023-09-01
category:
    - 浏览器
tag:
    - 缓存
---

# HTTP 缓存

前几天在想如何解决图片加载的问题时，想到了用 redis 区实现。大致的思路是就是将已经请求过的图片资源存放在 redis 中。但是后面又想了一下，这样会很浪费资源。不仅本地存了原始的图片文件，数据库中存了图片对应的 base64，如果还往 redis 中再存一份的话，会非常的浪费空间资源。

今天在思考的时候，突然想到可以利用浏览器的缓存来实现。于是又去看了一下缓存相关的知识，也算是再复习一遍了。

缓存相关的主要知识慢慢的补充，这里先讲一下我是如何解决的。

## 例子

在后端相关的请求借口设置相应头，拿 nest 举例：

```ts
 /**
 * 获取单个图片信息
 */
@Get()
@Header('Cache-Control','max-age=1000')
findOne(@Query('id') id: number) {
    return this.imageService.findOne(+id);
}
```

对应的请求接口为：`http://localhost:3000/image`

没错这里用到的是`强缓存`，前端在第一次请求这个接口的时候，该接口会正常的响应。

由于在响应头里面设置了`Cache-Control`，并且过期时间为`1000s(max-age=1000)`。

比如我现在请求了一个 id 为 16 的信息，那么对应的请求 url 就是:`http://localhost:3000/image?id=16`

所以在接下来的 1000 秒内，对于请求同一个资源，也就是通过该浏览器请求相同的 url 路径时，该接口都不会被请求到。也就是所谓的命中了强缓存，直接走了浏览器的本地缓存。

除非使用强制刷新或者过了 1000s，才不会走强缓存。

** 需要注意的是： **

1. 除了 get 请求，其它的请求方式不能被缓存

2. http 缓存有大小限制

就比如这个例子:

```ts
/**
 * 获取全部信息
 */
@Get('/all')
@Header('Cache-Control','max-age=20000')
findAll() {
    console.log('get!')
    return this.imageService.findAll();
}
```

请求这个接口会返回所有的图片数据（70M），但是我发现不管我如何请求，都不会走强缓存，虽然返回的都是状态码都是 200。

后面百度+尝试发现：chrome 内核的浏览器（我用的是 Arc 浏览器）HTTP 缓存的上限是 40M。

小于这个值都能成功的命中强缓存。

好了，知道了这些，解决公司的那个问题基本的思路能确定了。

1. 前端请求数据的方式改为 get

2. 后端相关的接口设置响应头，启用强缓存

3. 每次重新开启的增强预览请求的路径中都带上本次增强的唯一 uuid，避免前后两次的冲突

4. 确定一个合理的缓存过期时间

面对上面的第四点，引发出一个新的问题，就是如何解决大量缓存的堆积问题

# 强缓存
