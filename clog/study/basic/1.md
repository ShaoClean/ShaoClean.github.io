---
icon: computer
category:
  - 数据结构
tag:
  - 学习笔记
---
# 数据结构

可以分为下面三大类

- 数据的逻辑结构

  - 线性结构

    指数据元素之间存在一对一的关系

    线性表、栈（特殊线性表）、队列（特殊线性表）、字符串、数组、广义表

  - 非线性结构

    指数据元素之间存在一对多或者多对多的关系

    树形结构（一对多）、图形结构（多对多）

- 数据的存储结构

  - 顺序存储
  - 链式存储

- 数据的运算

​	检索、排序、插入、删除、修改等

## 1.绪论

### 算法和算法分析

#### 算法特性
- 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷事件内完成
- 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入：一个算法有0个或多个输入
- 输出：一个算法有一个或多个输出

#### 算法设计要求
- 正确性
- 可读性
- 健壮性
- 高效性

#### 算法分析
如何衡量一个算法的好坏？
一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。
主要考虑下面两个方面：

- 时间效率：指的是算法所耗费的时间
- 空间效率：指的是算法执行过程中所耗费的存储空间

**1.算法时间效率的度量**
算法运行时间 = 一个简单操作所需的时间 * 简单操作次数 = （每条语句频度 * 该语句执行一次所需的时间）求和 

若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。
记作T(n)=O(f(n))，称O(f(n))喂算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度

<span style='color:red'>例</span>：
求`T(n) = 2n^3 + 3n^2 + 2n + 1`的时间复杂度

根据定义，需要找到一个辅助函数f(n)，当n趋近于无穷大时，使得T(n)/f(n) ～ 常数（0除外）。

因为n是趋近于无穷大的，所以可以得出T(n)的极限值为2n^3。

因此问题就变成了2n^3/f(n) ～ 常数（0除外），也就是说当n充分大的时候，T(n)的数量级为n^3，T(n)于n^3是同一个数量级的（同阶）

那么此时，易得f(n) = n^3，常数为2

所以T(n) = O(n^3)

**2.算法空间复杂度的度量**

空间复杂度：算法所需存储空间的度量（其中n为问题的规模（或大小）
$$
S(n) = O(f(n))
$$
算法要占据的空间可以是：

- 1.算法本身要占据的空间，输入\输出，指令，常数，变量等
- 2.算法要使用的辅助空间

<span style='color:red'>例</span>：

实现将数组a中的数据逆序的存放到数组b中

```javascript
//算法1
for(let i=0;i<n/2;i++){
  t = a[i];
  a[i] = a[n-i-1];
  a[n-i-1] = t;
}

//算法2
for(let i=0;i<n;i++){、
	b[i] = a[n-i-1];
}
for(let i = 0;i<n;i++){
  a[i]=b[i]
}
```

分析：

在算法一中，涉及到了一个新的中间变量来存储，且这个变量每次的存储个数固定为1。所以可以可以得到算法1中的空间复杂度为1。用公式可以表示为：
$$
S(n) = O(1)
$$
在算法二中，涉及到了一个新的数组用来转换。这个数据的长度个数为n的，所以空间复杂度为n。可以用公式表示为：
$$
S(n) = O(n)
$$

## 2.线性表

### 1.线性表的定义和特点

线性表是具有**相同特性**的数据元素的一个有限序列。

线性表的逻辑特征：

- 1.在非空的线性表，有且仅有一个开始节点$a_1$，它没有直接前趋，而仅有一个直接后继$a_2$；
- 2.有且仅有一个中断节点$a_n$，它没有直接后继，而仅有一个直接前趋$a_{n-1}$
- 3.其余的内部节点$a_i(2 \leq i \leq n-1)$都有且仅有一个直接前趋$a_{i-1}$和一个直接后继$a_{i+1}$

 顺序存储结构存在问题：

- 存储空间分配不灵活
- 运算的空间复杂度高

### 2.线性表的类型定义

**线性表的基本操作**

- 1.InitList(&L)

  构造一个空的线性表L

- 2.DestoryList(&L)

  线性表L存在的情况下

  销毁线性表L

- 3.ClearList(&L)

​		线性表L存在的情况下		

​		将线性表L重置为空表

- 4.ListEmpty(&L)

  线性表L存在的情况下

​	   若线性表L为空表，则返回true；否则返回false。

- 5.ListLength(&L)

​		线性表L存在的情况下

​		返回线性表L中的数据元素个数

- 6.GetElem(L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)

​		用e返回线性表L中第i个数据元素的值。

- 7.LocateElem(L,e,compare())

​		线性表L存在的情况下,compare()是数据元素判定函数

​		返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0

- 8.PriorElem(L,cur_e,&pre_e)

​		线性表L存在的情况下，cur_e表示当前元素

​		若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无意义。

- 9.NextElem(L,cur_e,&next_e)

​		线性表L存在的情况下

​		若cur_e是L的数据元素，且不是最后一个。则用next_e返回它的后继元素，否则操作失败，next_e无意义

- 10.ListInsert(&L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)+1

​		在L的第i个位置之前插入新的数据元素e，L的长度加一

- 11.ListDelete(&L,i,&e)

​		线性表L存在的情况下,1<=i<=ListLength(L)

​		删除L的第i个数据元素，并用e返回其值，L的长度减一

- 12.ListTraverse(&L,visited())

​		线性表L存在的情况下

​		依次对线性表中每个元素调用visited()函数

以上运算操作是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于”如何做“等实现细节，只有待确定了存储结构之后才考虑

### 3.线性表的顺序表示和实现

在计算机内，线性表有两种基本的存储结构：`顺序存储结构`和`链式存储结构`

**顺序存储定义：**把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构 

所有数据元素的存储位置均可由第一个数据元素的存储位置得到：
$$
LOC(a_i) = LOC(a_1) + (i-1)\times l
$$
## 3.散列表

使用散列表要解决好两个问题：
**1.构造好的散列函数**
	（a）所选的函数尽可能简单，以便提高转换速度
	（b）所选函数对关键码计算出的地址，应在散列地址集中均匀分布，以减少空间浪费
**2.制定一个好的解决冲突的方案**
	查找时，如果散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。

### 散列函数的构造方法
#### 1.直接定址法
$$
Hash(key) = a\times key + b
$$
优点：以关键码key的某个线性函数为散列地址，不会产生冲突
缺点：要占用连续地址空间，空间效率低

#### 2.除留余数法
$$
Hash(key) = （key） mod （p）
$$
p是一个整数。

技巧：
设表长为m，取p<=m且为质数

### 解决冲突
#### 1.开放定址法
基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入

**常用方法：**
1.**线性探测法**：当前位置有冲突，就在该位置的基础上上+1，如果+1后还是有冲突，就+2，以此类推
2.**二次探测法**：v当前位置有冲突，就在该位置上的基础上+$1^2$，如果+$1^2$后还是有冲突，就-$1^2$；如果还是存在冲突，就查找+$2^2$，-$2^2$。。。以此类推
3.**伪随机探测法**：当前位置有冲突，在当前位置上加上一个随机数

#### 2.链地址法（拉链法、分离链接）
基本思想：相同散列地址的记录链成一张单链表
m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构

链地址法建立散列表步骤：
1.取数据元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素茶如此链表；否则执行步骤2解决冲突
2.根据选择的冲突处理方法，计算关键字key的下一个存储地址。若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表。

**优点：**
1.非同义词不会冲突，无聚集现象
2.链表上的节点空间动态申请，更适合于表长不确定的情况

### 散列表的查找

散列表是基于数组实现的，由于数组的查询速度是非常快的，可以通过它的下标在内存中快速的找到它的位置，把它的所对应的值拿出来。

但是字典这种数据结构，是通过键值对这样的方式来存储的，想找到其中的某个键所对应的值，最坏的情况就是遍历整个字典才能找到。

如果将字典的键转换为数组的下标，就可以利用数组的特性快速的进行查找