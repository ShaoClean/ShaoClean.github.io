---
icon: computer
date: 2023-02-23
category:
  - 前端
  - 计算机网络
tag:
  - TCP
  - 学习笔记
---

# TCP

它是一个面向连接、可靠、基于字节流的传输（运输）层协议。

运输层直接为应用进程见的逻辑通信提供服务。

## TCP 的优势

### 1.数据分片

在发送端将用户数据进行分片，在接收端进行重组，由 TCP 确认分片的大小并控制分片和重组

为什么会分片？是因为有一个发送数据的最大长度段，所以要将待发送的数据进行分片。

TCP 发送数据前会将要发送的数据进行分割，分割成一块一块的数据块，这些数据块称为段（Segment），这些段只包含数据，不包含首部协议。而在这些数据段之上有一个最大数据段的概念，MSS（Max Segment Size）。

### 2.到达确认

接收端接收到数据分片时，根据分片数据序号向发送端发送一个确认

### 3.超时重发

发送方在在发送分片的时候启动超时定时器，如果在超过定时器的时间内没有收到确认信号，重发分片

### 4.滑动窗口（流量控制）

> 所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接收，利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。

- TCP 连接的每一方都有接收数据的缓冲空间，其大小是固定的。接收数据的一端只允许接收它缓冲区所允许接纳的数据。TCP 在滑动窗口的基础上提供流量控制，防止发送数据较快的主机致使接收数据较慢的主机的缓冲区溢出的问题。

  - TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小

  - TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。

**工作原理：**
首先，TCP 不是每个报文段都会返回 TCP 的，可能对多个报文返回一个 ACK。

举例：制造某机器需要 A，B，C 三种零件，并且组装顺序 A→B→C，某天不凑巧，B，C 零件先到，这个时候往往把 A 的位置预留出来，等待 A 到达之后，再进行组装；如果 A 丢失了，那么 B，C 也丧失作用，被丢弃了。

在 TCP 中也有这样一个“预留的地方”，我们称之为“空洞（hole）”。假设我们依次发送 3 个报文（A，B，C）。如果 B，C 报文先到，那么先把 A 的位置预留出来，只有 A 报文到达了，接收端才返回一个 ACK（不是 3 个）进行确认。

- 1.TCP 在传输数据的时候，将数据分成几段，seg1、seg2、seg3、seg4，将这些段依次发送出去

- 2.假设接收端接收到了分段 seg1、seg2、seg4，此时接收端会发送一个 ACK（Acknowledge）包告诉发送端已经接收到这些数据，并将 seg4 进行缓存（为了保证顺序，产生一个保存 seg3 的 hole）

- 3.发送端接收到 ACK 包之后，将对应的数据包改为已确认状态，这时候窗口向右移动

- 4.假设接收端通告的 Window Size 不变，此时窗口向右移动，产生一些新的空位，这些空位是接收端允许发送的范畴

- 5.对于丢失的 seg3，如果超过一定的时间没有送达，TCP 就会重新传送（重传机制），重传成功 seg3、seg4 会一起被确认接收；不成功 seg3 和 seg4 会被一起丢弃。

### 5.拥塞控制

> 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫拥塞控制。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。

**输入负载**（代表单位时间内输入给网络的分组数量）

**吞吐量**（代表单位时间内从网络输出的分组数量）

- 具有理想拥塞控制的网络：

在吞吐量达到饱和之前，网络吞吐量应该等于所输入的负载量。但当输入负载超过某一限度时，由于网络资源受限，吞吐量就不再增长而保持水平线（也就是吞吐量达到饱和）。

- 如果没有拥塞控制

当输入负载无限制的增大时，会导致网路吞吐量的下降，也就是出现拥塞的情况。当输入的负载增大到某一个值时，出现了重度的拥塞情况，网络的吞吐量下降到0时，会出现死锁的情况。所以进行拥塞控制是非常有必要的。

#### 四种拥塞控制算法

TCP有四种拥塞控制算法，分别是**慢开始（Congestion avoidance）、拥塞避免（Congestion avoidance）、快重传（fast retransmit）、快恢复（fast recovery）**。

#### 前提条件

了解四种拥塞控制算法的基本原理，要假定如下条件：

1. 数据是但方向传送，而另一个方法只传送确认
2. 接收方总是有足够大的缓存空间，因而发送方窗口的大小由网络的拥塞程度来决定
3. 以最大报文段（MMS）的个数为讨论问题的单位，而不是以字节为单位。

#### 拥塞窗口

发送方发送数据的时候，会维护一个叫做**拥塞窗口CWnd（congestion window）**的状态变量，其值取决于网络的拥塞程度，并且动态变化。

##### 拥塞窗口原则

- 只要网络没有出现拥塞，拥塞窗口就再大一些；但只要网络只要出现拥塞，拥塞窗口就减少一些。判断出现网络出现拥塞的依据：没有按时收到应当到达的确认报文（即发生超时重传）
- 发送方将拥塞窗口作为**发送窗口SWnd（Send Window）**，即swnd==cwnd
- 发送方维护一个慢开始门限**ssthresh（Slow Start Threshold）**状态变量
  - 当cwnd<ssthresh，使用慢开始算法
  - 当cwnd>ssthresh，使用拥塞避免算法
  - 当cwnd=ssthresh，慢开始算法、拥塞避免算法都可以使用



#### 过程

1. 当发送方和接收方建立TCP连接后，发送方的cwnd设置为1并设置ssthresh的初始值为16（这个16用于举例，1是定的）。
2. 当发送方接收到接收方返回的确认报文段之后，将这个ssthresh值加上当前的ssthresh值。
3. 当这个ssthresh值达到初始的设定值之后，就会使用拥塞避免算法。
4. 拥塞避免算法使发送方接收到接收方返回的数据报文段后，每次ssthresh值加1
5. 假如数据报文段在发送的过程中出现了丢失的情况，会触发发送方对发送报文段的超时重传
6. 发送方还会判断网络很可能出现了拥塞，将ssthresh值更新为发生拥塞时cwnd的一半
7. 将cwnd值设置为1，并重新执行慢开始算法

当前发送方的发送窗口（可发送的数据报文段）数量为cwnd的值，也就是说cwnd的值是几，就能发送几个数据报文段。

#### 快重传和快恢复

慢开始和拥塞避免算法使1988年提出的TCP拥塞控制算法（TCP Tahoe版本）

1990年又增加了两个新的拥塞控制算法改进TCP的性能，这就是快重传和快恢复（TCP Reno版本）

##### **为什么需要快重传和快恢复**

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。这将导致发送方超时重传，并误认为网络发生了拥塞，并且发送方将cwnd值设置为1，但此时并没有发生网络拥塞，错误的启动了慢开始算法，降低了传输速率。

- 使用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。

##### 快重传

所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时的时候再重传。

- 这就要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认
- 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认
- 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等待该报文段的超时重传计时器超时再重传
- 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低cwnd为1）
- 快重传可以是整个网络的吞吐量提高约20%

##### 快恢复

所谓快恢复，就是发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而是执行快恢复算法。

- 发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法
- 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，也就是ssthresh+3（既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中；可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些）

![image-20230224124546249](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7374/image-20230224124546249.png)

### 6.失序处理

传输的 TCP 分片数据到达时可能会出现失序的情况，TCP 将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

### 7.重复处理

传输的 TCP 分片数据到达时可能会出现重复的分片，TCP 的接收端必须丢弃重复的数据。

### 8.数据校验

TCP 将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收到分片的检验和有差错，TCP 将丢弃这个分片，并且不会确认收到次报文段，然后就会导致发送端对这一数据分片的超时并重发该分片。

**什么是检验和？**
检验和是存在于各种报文中的一个字段，它存在的目的是验证报文在网络传输过程中的完整性（有的数据可能在链路传输时发生 0-1 数据翻转，从而导致报文出错）。因此，在报文的发送端，会根据报文中的首部或数据来计算一个检验和（IP 报文的检验和只对首部进行计算，ICMP 报文对报文首部和数据都进行计算），然后一旦接收端接受到相应报文，接收端也会对报文的首部或数据进行一次检验和计算，如果接收端算出来的检验和和发送端发送的不一样，那么对不起，接收端认为报文在传输过程中出了错，于是就丢掉该报文。
