---
icon: java
date: 2022-07-30
star: 8
category: 
  - 后端
  - Java
tag:
  - JavaSE
---
# JavaSE

# 一、什么是JDK、JVM、JRE

## JDK

JDK：Java Development Kit （Java开发工具包）

JDK= JRE + 开发工具集（java，javac，javadoc，javap）

JDK是提供给java开发人员使用的，其中包含了java的开发工具，也包括了JRE，所有安装了JDK，就不用在单独安装JRE了

## JVM

JVM：java virtual macchine

JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，它包含在JDK中，java虚拟机机制跑步了底层运行平台的差别，实现一次编译，到处运行。

## JRE

JRE：Java Runtime Environment（Java运行环境）

JRE=JVM + Java的核心类库【类】（Java SE标准类库）

如果想要运行一个开发好的Java程序，计算机中只需要有JRE就能运行

# 二、转义字符

`\t`:一个制表单位，实现对齐的功能

`\n`:换行符

`\\`:一个\

`\"`:一个"

`\'`:一个'

`\r`:一个回车

# 三、注释

单行注释： `//我是单行注释`

多行注释：

```java
/*
我是多行注释
*/
```

文档注释：

```java
/*
	*@author xxx
	*@version x.x.x
	*@deprecated 指一个过期的类或成员
	*@docRoot 当前文档根目录的路径
	*@exception 表示一个类抛出的异常
	*@inheritDoc 从直接父类继承的注释
	*@link 插入一个到另一个主题的链接，
	*@linkplain 插入一个到另一个主题的链接，但是该链接显示纯文本字体
	*@param 说明一个方法的参数
	*@return 说明返回值类型
	*@see 指定一个到另一个主题的链接
	*@serial 说明一个序列化属性
	*@serialData 说明通过writeObject（）和writeExternal（）方法写的数据
*/
```

生成文档指令：`javadoc -d 文件夹名称 -xx -yy java文件名称`

# 四、路径

相对路径：从当前目录开始定位，形成的一个路径

绝对路径：从顶级路径开始定位，形成的一个路径

# 五、数据类型

变量表示内存中的一个存储区域

## 1.基本数据类型

数值型：整数类型、浮点（小数）类型

字符型：char

布尔型：boolean

**整数**：

`byte`:1字节，-128(-2的7次方) ～ 127(2的7次方-1)

`short`:2字节，-32768(-2的15次方) ～ 32767 (2的15次方-1)

`int`:4字节,-2147483648 (-2的31次方) ～ 2147483647 (2的31次方-1)

`long`:8字节,-9223372036854775808 (-2的63次方) ～ 9223372036854775807 (2的63次方-1)

⚠️注意：Java的整型常量（具体值，如2，33）默认为int类型，声明long型常量需要在后面加上`l`或者`L`

**浮点（小数）类型：**

`float`:4字节,1.4E-45 (2的-149次方) ~ 3.4028235E38 (2的128次方-1)

`double`:8字节,4.9E-324 (2的-1074次方) ~ 1.7976931348623157E308 (2的1024次方-1)

⚠️注意：Java的浮点型常量（具体值，如2.2，33.3）默认为double类型，声明float型常量需要在后面加上`f`或者`F`。

当我们对运算结果是小数的进行相等判断时，要小心（应该是以两个数的差值的绝对值，在某个精度范围内）

**字符类型：**

`char`:2字节

```java
char c1 = '邵';//不能用双引号，双引号表示字符串类型
char c2 = 97;//字符类型可以直接存放一个数字
System.out.println(c2);//当输出c4时候，会输出97表示的字符 =》编码的概念
```

⚠️注意：

- 字符常量是用单引号`''`括起来的单个字符。例如：`char c1 = '邵';char c2 = 'a';char c3 = '9';`但是不能用双引号`""`，双引号表示字符串类型。
- 允许使用转义字符`\`来将其后的字符转变为特殊字符型常量。例如：`char c3= '\n'`
- char的本质是一个整数，在输出时，是unicode码对应的字符
- 可以给char类型的变量直接存放一个整数，然后输出时，会按照对应的unicode字符输出
- char类型时可以进行运算，相当于一个整数，因为它都对应有unicode码

字符类型本质探讨：

- 字符型存储到计算机中，需要将字符对应的码值（整数）找出来
- 字符和码值的对应关系是通过字符编码表决定的
  - ASCII（ASCII编码表用一个字节表示，一共128个字符，实际上一个字节可以表示256个字符，只用128个）
  - Unicode（Unicode编码表，固定大小的编码，使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间）
  - utf-8（大小可变的编码，字母使用1个字节，汉字使用3个字节）
  - GBK（可以表示汉字，而且范围广，字母使用1个字符，汉字2个字节，可以表示的汉字数量少）
  - gb2312（可以表示汉字，gb2312<gbk）
  - big5码（繁体中文，台湾，香港）

**布尔类型：**

`boolean`:1字节

### 基本数据类型转换：

自动提升原则：当java程序进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这就是自动类型转换。

char=>int=>long=>float=>double

byte=>short=>int=>long=>float=>double

注意：

- 有多种类型的数据混合运算时，系统首先自动将多有数据转换成容量最大的那种数据类型，然后再进行计算

- `byte, short`和`char`之间不会相互自动转换

- 当把一个具体的数（如果是变量赋值，则会判断类型）赋值给byte类型时，先判断该数是否在byte范围内，如果是就可以。

- `byte`、`short`、`char`他们三者可以计算，在计算时首先转换为`int`类型（无论是相同类型的运算还是混合运算，都会变成`int`类型）

- `布偶类型`不参与类型的自动转换

  ```java
  //1.
  byte b1 = 10;//对
  int n2 = 1;
  byte b2 = n2;//错误，变量赋值，会判断类型，类型不符合
  //2.
  char c1 = b1;//错误，byte不会自动转成char
  //3.
  byte b2 = 1;
  byte b3 = 2;
  short s1 = 1;
  short s2 = b2 + s1;//错， b2+s1 =》 int
  //4.
  byte b4 = b2 + b3;//错，b2 + b3=》int
  //5.
  boolean pass = true;
  int num100 = pass;//boolean 不参与类型的自动转换
  //6.
  byte b4 = 1;
  short s3 = 100;
  int num200 = 1;
  double num300 = 1.1;
  double num500 = b4 + s3 + num200 + num300;//允许
  ```

### 强制类型转换:

介绍：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符`()`，但可能造成精度降低或溢出，格外要注意。

- 当进行数据类型的大小从大=》小的转换时，就需要使用到强制类型转换

- 强转符号只针对最近的操作数有效，往往会使用小括号来提升优先等级

- `char`类型可以保存`int`类型的常量值，但不能保存`int`类型的变量值，需要强转

- `byte`、`short`、`char`类型在进行运算时，当作`int`类型处理

  ```java
  char c1 = 100;//ok
  int m = 100;//ok
  char c2 = m;//wrong
  char c3 = (char)m;//ok
  ```

### 基本数据类型和String类型的转换：

介绍：在程序开发中，我们经常需要将基本数据类型转成`String`类型。或者将`String`类型转成基本数据类型

- 基本类型转String类型：将基本类型的值加上`“”`即可
- `String`类型的数据转换成基本数据类型：通过基本类型的包装类调用`parseXX`方法即可

```java
//String => 对应的基本数据类型
//使用基本数据类型对应的包装类的相应方法，得到基本数据类型
String s5 = "123";
int num1 = Integer.parseInt(s5);
double num2 = Double.paresDouble(s5);
float num3 = Float.paresFloat(s5);
long num4 = Long.parseLong(s5);
byte num5 = Byte.parseByte(s5);
boolean b = Boolean.parseBoolean("true");
short num6 = Short.parseShort(s5);

//字符串转成字符（char类型）：得到字符串类型数据中的第一个字符
//取出s5字符串中的第一位，得到字符‘1’，而不是数字1
System.out.println(s5.charAt(0))
```

- 在将`String`类型转成`基本数据类型`时，要确保`String`类型能够转成有效的数据，比如可以把`”123“`转成一个整数，但是不可以将`”hello“`转换成一个整数
- 如果格式不正确，就会抛出异常，程序就会终止，需要`处理异常`

## 2.引用数据类型

类、接口、数组

# 六、运算符

## 1.运算符介绍

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。

## 2.算数运算符

介绍：算数运算符是对数值类型的变量进行运算的，在java中使用的非常多。

`a.取模（求余）`：

取模的本质：`a % b = a - a / b * b;`

当a为小数时，必须要使用公式运算`a - (int)a / b * b;`

小结：要判断取模后的结果是正数还是负数，只需要在原有的两个数相乘的基础上，再乘上后面的数，三个数相乘是正数则是正数，是负数则是负数

`b.自增运算符(自减运算符同理)：`

⚠️注意：

- 如果作为独立语句使用，自增运算符放在后面和前面都完全等价`i = i + 1`
- 如果作为表达式使用，前`++`先自增后赋值，后`++`先赋值后自增



`++`(前)：先运算，后取值



```java
int a = 2;
int b = ++a;//等价：a=a+1;b=a;
// a = 3;
// b = 3;
```



`++`(后)：先取值，后运算

```java
int a = 2;
int b = a++;//等价：b=a;a=a+1;
// a = 2;
// b = 3;
```



## 3.关系运算符【比较运算符】

介绍：关系运算符的结果都是boolean类型，关系表达式经常用在if结构的条件中或循环结构的条件中

## 4.逻辑运算符

介绍：用于连接多个条件（多个关系表达式），最终的结果也是一个boolean类型

**&&和&区别**

- &&短路与：如果第一个条件喂false，则第二个条件不会判断，最终结果为false
- &逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低
- 开发中基本使用短路与&&，效率高

**||和|区别**

- ||短路或：如果第一个条件为true，则第二个条件不会判断，最终结果为true，效率高
- |逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低
- 开发中基本使用||短路或

**^**

- a^b:逻辑异或，当a和b不同时，结果为true，否则为false

## 5.赋值运算符

介绍：将某个运算后的值，赋给指定的变量

## 6.三元运算符

使用细节：

- 表达式1和表达式2要为可以赋给接收变量的类型（返回的结果数据类型需要相同，或可以自动转换的类型）
- 三元运算符可以转成if--else语句

## 7.位运算符

对于有符号的数而言：

- 二进制的最高位是符号位（+/-）：0表示正数，1表示负数
- 正数的原码，反码，补码都一样（三码合一）
- 负数的反码=它的原码符号位不变，其它位取反（0变成1，1变成0）
- 负数的补码=他的反码+1，负数的反码=负数的补码-1
- 0的反码，补码都是0
- java没有无符号数，换言之，java中的数都是有符号的
- 在计算机运行的时候，都是以补码的方式来运算的
- 当我们看运算结果的时候，要看他的原码

**位运算符：**

介绍：java中有7个位运算符（&、|、^、~、>>、<<、>>>）

- **按位与&：**两位全为1，结果为1，否则为0

`2&3 = 2 `

1.  先得到2的原码00000000 00000000 00000000 0000010
2. 得到2的补码，2的补码结果和原码相等
3. 得到3的原码00000000 00000000 00000000 00000011
4. 得到3的补码，3的补码结果和原码相等
5. 计算按位与&的结果（补码）：00000000 00000000 00000000 0000010
6. 计算运算后的原码：00000000 00000000 00000000 0000010

- **按位或|：**两位有一个1，结果为1，否则为0
- **按位异或^：**两位一个为0，一个为1，结果为1，否则为0
- **按位取反~：**0变成1，1变成0

`~-2 = 1`

1.  先得到-2的原码10000000 00000000 00000000 0000010
2. 得到-2的反码11111111 11111111 11111111 11111101
3. 得到-2的补码11111111 11111111 11111111 11111110
4. ～-2运算后的补码00000000 00000000 00000000 00000001
5. 运算后的原码：00000000 00000000 00000000 00000001
6. 转换成十进制数：1

- **算数右移>>：**低位溢出，符号位不变，并用符号位补溢出的高位

`int a = 1>>2;//1 =>00000001 => 00000000 本质 1 / 2 / 2 `

- **算数左移<<：**符号位不变，低位补0

`int b = 1<<2;//4 =>00000100 => 00000000 本质 1 * 2 * 2 `

- `>>>`逻辑右移也叫无符号右移，运算规则：低位一处，高位补0

## 8.运算符优先级

# 七、进制

介绍：对于整数，有四种表示方式：

- 二进制：0，1，满2进1。以0b或0B开头
- 八进制：0-7，满8进1.以数字0开头
- 十进制：0-9，满10进一
- 十六进制：0-9以及（10）-F（15），满16进1.以0x或0X开头表示，A- F不区分大小写。

## 其它进制转十进制：

- 二进制转十进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和

例：0b1011转换成十进制

`0b1011 = 1*2的0次方 + 1*2的1次方 +0*2的2次方 + 1*2的3次方 =11    `

- 八进制转十进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和

例：0234转换成十进制

`0234 = 4*8的0次方 + 3*8的1次方 + 2*8的2次方 = 156    `

- 十六进制转十进制

规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和

例：0x23A转换成十进制

`0x23A = 10*16的0次方 + 3*16的1次方 + 2*16的2次方 = 570    `

## 十进制转其它进制

- 十进制转二进制

规则：除2倒取余数法

`123 = 0b01111011`

- 十进制转八进制

规则：除8倒取余数法

`678 = 01246`

- 十进制转十六进制

规则：除16倒取余数法

`8912 = 0x22D0`

## 二进制转其它进制

- **二进制转八进制**

规则：从低位开始，将二进制数每三位一组（0b111 == 7），转成对应的八进制数

`0b11010101 = 0325`

1. 101转成八进制 = 5
2. 010转成八进制 = 2
3. 11转成八进制 = 3

- **二进制转十六进制**

规则：从低位开始，将二进制数每三位一组（0b1111 == 15），转成对应的十六进制数

`0b11010101 = 0xD5`

1. 0101转成十六进制 = 5
2. 1101转成十六进制 = D

## 其它进制转二进制

- 八进制转二进制

规则：将八进制数每一位，转成对应的一个3位二进制数

`0237 = 0b010011111`

1. 7转成二进制 = 111

2. 3转成二进制 = 011
3. 2转成二进制 = 010

- 十六进制转二进制

规则：将十六进制数每一位，转成对应的一个4位二进制数

`0x23B = 1000111011 `

1. B转成十六进制 = 1011
2. 3转成十六进制 = 0011
3. 2转成十六进制 = 0010

# 八、结构控制语句

switch：

- 表达式数据类型应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型
- switch表达式中的返回值必须是：byte、short、int、char、enum、String中的类型

- case子句中的值必须是常量或者是常量表达式，而不能是变量

# 九、数组

介绍：数组可以存放多个同一类型的数据，数组也是一种数据类型，数组是引用数据类型

## 1.数组的使用

- 动态初始化

`int[] a = new int[5]//创建了一个数组，名字a，存放五个int`

- 动态初始化2

```java
int a[];//声明数组，此时a == null
a = new int[10];//分配内存空间，可以存放数据
```

- 静态初始化

`int a[] = {1,2,3,4,5,6};`

## 2.数组细节

- 数组是多个相同类型数据的组合，实现对这些数据的统一管理
- 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用
- **数组创建后，如果没有赋值，有默认值**：int,short,byte,long 的默认值是 0，double、float的默认值是0.0，char的默认值是\u0000,boolean的默认值是 false，String的默认值是null
- 数组使用步骤：1.声明数组并开辟空间2.给数组各个元素赋值3.使用数组
- 数组的下标从0开始
- 数组下标必须在指定范围内使用，否则报错：下标越界异常
- 数组属于引用类型，数组型的数据是对象（object）

## 3.数组赋值机制

- 基本类型肤质，这个值就是具体的数据，而且互相不影响（赋值方式为值拷贝/值传递）
- 数组在默认情况下是引用传递，赋的值是地址（赋值方式为引用传递/地址拷贝）

```java
int[] arr1 = {1,2,3};
int[] arr2 = arr1;
```

arr2的变化会影响到arr1

jvm内存：栈、堆、方法区三大类

## 4.二维数组

初始化方式：

- 动态初始化1：`int[][] a = new int[2][3]`

- 动态初始化2:

```java
int arr[][];
arr = new int[2][2];
```

- 动态初始化3:

  不确定二维数组中的数组长度时，需要给每一个一维数组开辟空间，如果没有开辟空间，那么arr[i]就是null

```java
int arr = new int[3][];
for(int i = 0;i < arr.length; i++){
  arr[i] = new int[i + 1];
}
```

- 静态初始化

```java
int arr[][] = {
  {1,2},
  {2,3,4}
}
```

# 十、类与对象

## 属性

- 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名
- 属性的定义类型可以为任意类型，包含基本类型和引用类型
- 属性如果不赋值，则有默认值，规则和数组一致

## 类与对象内存的分配机制

java内存结构分析：

- 栈：一般存放基本数据类型
- 堆：存放对象
- 方法区：常量池（常量，比如字符串），类加载信息

Java创建对象的流程

- 先加载类信息（属性和方法信息，只会加载一次）
- 在堆中分配空间，进行默认初始化， 
- 把地址赋给相对应的实例，实例就指向对象
- 进行指定初始化

## 成员方法（方法）

### 方法调用小结：

- 当程序执行到方法时，就会开辟一个独立的空间（栈空间）
- 当方法执行完毕，或者执行到return语句时，就会返回
- 返回到调用方法的地方
- 返回后，继续执行方法后面的代码

### 方法的好处：

- 提高代码的复用性
- 可以将实现的细节封装恰里，然后供其他用户来调用

### 注意事项：

- 访问修饰符（作用是控制方法的使用范围）
  - public
  - protected
  - private
  - 默认
- 返回数据类型：
  - 一个方法最多有一个返回值（如果需要返回多个，可以使用数组）
  - 返回类型是任意的，包含基本类型或引用类型（数组、对象）
  - 如果方法要求有返回数据类型，则方法体中最后的执行语句为return值，而且要求返回值类型必须和return的值类型一致或者兼容
  - 如果方法是void，则方法体中不能有返回值
- 参数：

  - 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数
- 方法调用：
  - 同一个类中的方法调用：直接调用即可
  - 方法中不能再定义方法
  - 跨类中的方法调用：需要通过对象名调用（先创建对象，后调用）
  - 跨类调用方法时还与方法的访问修饰符、包等有关

### 方法递归调用：

- 执行一个方法时，就创建一个新的受保护的栈
- 方法的局部变量是独立的，不会相互影响
- 如果方法中使用的是引用类型变量（比如数组、对象） ，就会共享该引用类型的数据
- 递归必须向退出递归的条件逼近，否则就是无限递归，出现S他此刻OverFlowError
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 方法重载

介绍：Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致

- 减少起名字和记名字的麻烦
- 方法名：必须相同
- 形参列表：必须不同，形参类型或个数或顺序，至少有一样不同，参数名无要求
- 返回类型：无要求，返回类型不同不能构成方法重载

### 可变参数

概念：Java允许将同一个类中多个同名、同功能但参数个数不同的方法，封装成一个方法。

- 可变参数的实参可以是数组
- 可变参数的本质就是数组
- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后

```java
//使用可变参数求和
public int sum(int...nums){
	int res = 0;
  for(int i=0;i<nums.length;i++){
    res += nums[i];
  }
  return res;
}
sum();//0
sum(1,2,3);//6
sum({2,3,4})//9

```

## 十一、作用域

- 局部变量一般是指在成员方法中定义的变量
- 全局变量可以不赋值直接使用，因为有默认值。局部变量必须赋值才能使用，因为没有默认值。

## 十二、构造方法/构造器

介绍：

构造方法又较构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化

**基本语法：**

- 构造器的修饰符可以是默认，也可以是public、protected、private
- 构造器没有返回值,不能写void
- 方法名和类名必须一样
- 参数列表和成员方法一样的规则
- 构造器的调用系统完成

**使用细节：**

- 一个类可以定义多个不同的构造器，即构造器重载

- 如果没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器）。可以使用`javap指令`反编译查看

- 一旦定义了自己的构造器，默认的构造器就被覆盖了，除非显式的定义

  ```java
  class Person{
    String name;
    int age = 90;
    public Person(String pName,int pAge){
      name = pName;
      age = pAge;
    }
    Person(){}//显式定义无参构造器
  }
  Person p = new Person("clean",18)
  ```

**对象创建流程分析**

- 加载Person类信息，只会加载一次
- 在堆中分配空间（地址）

- 完成对象初始化
  - 默认初始化age =0，name = null
  - 显示初始化，age=90，name=null
  - 构造器初始化age = 18，name=clean

## 十三、this

哪个对象调用，this就代表哪个对象

- this关键字可以用来访问本类的属性、方法、构造器
- this用于区分当前类的属性和局部变量
- 访问成员方法的语法：this.方法名(参数列表)
- 访问构造器语法：this.(参数列表)，只能在构造器中使用（即只能在构造器中访问另外一个构造器，且访问 必须放在第一条语句。在成员方法中不能使用）
- this不能在类定义的外部使用，只能在类定义的方法中使用 

## 十四、包

**包的大三作用：**

- 区分相同名字的类
- 当类很多时，可以很好的管理类
- 控制访问范围



**包基本语法：**

- package关键字，表示打包
- com.clean：表示包名



**包的本质：**实际上就是创建不同的文件夹来保存类文件



**包的命名规则：**只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字



**命名规范：**小写字母+小圆点,com.公司名.项目名.业务模块名



**常用包：**

- java.lang.*：lang包是基本包，默认引入，不需要再引入
- java.util.*：util包，系统提供的工具包，工具类
- java.net.*：网络包，网络开发
- java.awt.*：java揭秘啊开发，GUI



**注意事项和使用细节：**

- `package`的作用是声明当前类所在的包，需要放在类的最上面，一个类中最到只有一句`package`
- `import`指令，位置在package的下面，在类定义前面，可以有多句且没有顺序要求



## 十五、访问修饰符

介绍：java提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

- public：公开级别，对外公开

- protected：受保护级别，对子类和同一个包中的类公开

- 默认：没有修饰符号，向同一个包的类公开

- private：只有类本身可以访问，不对外公开

| 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| :------------: | :--: | :--: | :--: | :----: |
|     public     |  ✔️   |  ✔️   |  ✔️   |   ✔️    |
|   protected    |  ✔️   |  ✔️   |  ✔️   |   ✖️    |
|      默认      |  ✔️   |  ✔️   |  ✖️   |   ✖️    |
|    private     |  ✔️   |  ✖️   |  ✖️   |   ✖️    |

**使用注意事项：**

- 修饰符可以用来修饰类中的属性、成员方法以及类

- 只有`默认修饰符`和`public`才能用来修饰类 

## 十六、封装（encapsulation）

介绍：把抽象出来的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序和其他部分只有通过被授权的操作（方法）才能对数据进行操作。隐藏实现细节，只需要传入相关的参数就可以实现方法

**封装实现步骤：**

- 将属性进行私有化（private）不能直接修改属性
- 提供一个公共的（public）set方法，用于对属性判断并赋值
- 提供一个公共的get方法，用于获取属性的值

## 十七、继承

介绍：继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的字类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。

- 子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问

- 子类必须调用父类的构造器，完成父类的初始化
- 当创建子类对象时，不管使用子类的哪个构造器，**<span style="color:red">默认情况下总会去调用父类的无参构造器</span>**，如果父类没有提供无参构造器，则必须在子类的构造器中使用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。
- 如果希望指定去调用父类的某一个构造器，则显式的调用一下
- super在使用时，需要放在构造器第一行
- super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
- java所有类都是Object类的子类
- 父类构造器的调用不限于直接父类。将一直往上追溯直到Object类（顶级父类）
- 子类最多只能继承一个父类（指直接继承），即Java中时单继承机制

我是A类

hahah我是B类的有参构造器

我是c类的有参构造器

我是c类的无参构造器

## 十八、方法重写

方法重写也叫方法覆盖，需要满足下面的条件

- 子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样。
- 子类方法的返回类型喝父类方法返回类型一样，或者是父类返回类型的子类
  - 比如父类方法的返回类型是Object，子类方法返回类型是String
- 子类方法不能缩小父类方法的访问权限

方法重载和方法重写的区别

| 名称 | 发生范围 | 方法名   | 形参列表                         | 返回类型                                                     | 修饰符                             |
| ---- | -------- | -------- | -------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 重载 | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无要求                                                       | 无要求                             |
| 重写 | 父子类   | 必须一样 | 相同                             | 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

## 十九、多态

**基本介绍：**

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

### **对象的多态：**

- 一个对象的编译类型和运行类型可以不一致

`Animal animal = new Dog();`

animal编译类型是Animal，运行类型是Dog

- 编译类型在定义对象时，就确定了，不能改变

- 运行类型是可以变化的

`animal = new Cat();`

animal运行类型变成了Cat，编译类型仍然是Animal

- 编译类型看定义时=号的左边，运行类型看=号的右边

**注意事项：**

多态的前提是：两个对象（类）存在继承关系

### **多态的向上转型**

- 本质：父类的引用指向了子类的对象

```java
Animal animal = new Cat();
Object obj = new Cat();
```

- 语法：父类类型 引用名 = new 子类型();

- 特点（规则）：

  - 编译类型看左边，运行类型看右边

  - 可以调用父类中的所有成员（需要遵守访问权限）

  - 不能调用子类中特有成员

    因为在编译阶段，能调用哪些成员，是由编译类型决定的

  - 最终运行效果看子类的具体实现

    首先是编译器将写好的代码进行编译，所以是先看编译类型。

    但是在代码的运行过程中，还是需要看运行类型（即调用方法时，按照子类开始网父类查找的方法）

### **多态的向下转型**

- 语法：`子类类型 引用名 = （子类类型）父类引用`

```java
Cat cat = (Cat) animal;
```

- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前目标类型的对象
- 可以调用子类类型中所有的成员

**注意**

- 属性没有重写之说，<span style="color:red;font-weight:800">属性的值看编译类型</span>

```java
public class polydetail2 {
    public static void main(String[] args) {
        Base base = new Sub();//向上转型
        System.out.println(base.count);//10,访问属性看的是编译类型，访问方法看的才是运行类型
    }
}
class Base{
    int count = 10;
}
class  Sub extends Base{
    int count = 20;
}
```

- instanceof 比较操作符，用于判断对象的**运行类型**是否为XX类型或XX类型的子类型

### 举例

举例1：

```java
public class polyExercise {
    public static void main(String[] args){
        double d = 13.4;//ok
        long l = (long)d;//ok
        System.out.println(l);//13.4
        
        int in = 5;//ok
        boolean b = (boolean)in;//wrong
        Object obj = "Hello";//ok
        String objStr = (String) obj;//ok
        System.out.println(objStr);//Hello
        
        Object objPri = new Integer(5);//ok
        String str = (String)objPri;//wrong
        Integer str1 = (Integer)objPri;//ok
    }
}
```

举例2：

```java
public class polyExercise2 {
    public static void main(String[] args) {
        Sub s = new Sub();
        System.out.println(s.count);//20
        s.display();//20
        Base b = s;
        System.out.println(b == s);//True
        System.out.println(b.count);//10
        b.display();//20
    }
}

class Base{
    int count = 10;
    public void display(){
        System.out.println(this.count);
    }
}

class Sub extends Base{
    int count = 20;

    public void display() {
        System.out.println(this.count);
    }
}
```

### java的动态绑定机制

基本介绍：

- 当调用对象方法的时候，该方法会和该对象的内存地址（运行类型）绑定
- 当调用对象属性时，没有动态绑定机制，那里声明，哪里使用

```java
public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//40
        System.out.println(a.sum1());//30
    }
}
class A{
    public int i = 10;

    public int sum(){
        return getI() + 10;
    }

    public int getI() {
        return i;
    }

    public int sum1(){
        return i + 10;
    }
    
}
class B extends A{
    public int i = 20;
    
    public int sum(){
        return i + 20;
    }

    public int getI() {
        return i;
    }
    
    public int sum1(){
        return i + 10;
    }
}
```

删除class B中的 两个sum方法之后：

```java
public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//30
        System.out.println(a.sum1());//20
    }
}
class A{
    public int i = 10;

    public int sum(){
        return getI() + 10;
      //1.在运行类型 B中没有找到sum方法。于是找到了父类A中的sum方法
      //2.因为动态绑定机制的原因，此时的getI()方法是class B中的方法，所以此时的getI()的值是20
      //3.返回sum方法的结果为20 + 10 == 30
    }

    public int getI() {
        return i;
    }

    public int sum1(){
        return i + 10;
      //1.在运行类型 B中没有找到sum方法。于是找到了父类A中的sum方法
      //2.因为属性不存在动态绑定机制的原因，此时的i是class A中的i，所以此时的i的值是10
      //3.返回sum1方法的结果为10 + 10 == 20
    }
    
}
class B extends A{
    public int i = 20;
    

    public int getI() {
        return i;
    }
    
}
```

## 二十、Object类

### equals方法

==和equals的对比：

- ==是一个比较运算符，不是一个方法
- ==既可以判断基本类型，又可以判断引用类型
- ==如果判断基本类型，判断的是值是否相等
- ==如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
- equals是Object类中的方法，只能判断引用类型（Object类的equals方法默认判断对象地址是否相等，子类中往往重写该方法，用于判断内容是否相等）

### hashCode方法

- 提高具有哈希结构的容器的效率
- 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
- 两个引用，如果指向的是不同对象，则哈希值是不一样的
- 哈希值主要根据地址号来，不能完全将哈希值等价于地址

### toString方法

默认返回：全类名（包名+类名）+@+哈希值的十六进制

```java
//Object的toString源码
public String toString(){
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```



子类往往重写toString方法，用于返回对象的属性信息

当直接输出一个对象时，toString方法会被默认的调用
