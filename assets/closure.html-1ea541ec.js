const e=JSON.parse('{"key":"v-00ea8174","path":"/study/frontend/js/closure.html","title":"闭包","lang":"zh-CN","frontmatter":{"icon":"javascript","date":"2022-09-09T00:00:00.000Z","star":20,"category":["前端","JS"],"tag":["闭包","学习笔记"],"description":"闭包 这是 MDN 上的描述： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 即： 闭包是在函数创建时创建的，所以函数创建就会生成闭包； 定义函数不会创建闭包，只有创建/执行函数同时才创建闭包； 闭包和其函数在同一上下文中 闭包包含该作用域下的所有变量/引用地址","head":[["meta",{"property":"og:url","content":"https://doc.shaoclean.top/study/frontend/js/closure.html"}],["meta",{"property":"og:site_name","content":"clog"}],["meta",{"property":"og:title","content":"闭包"}],["meta",{"property":"og:description","content":"闭包 这是 MDN 上的描述： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 即： 闭包是在函数创建时创建的，所以函数创建就会生成闭包； 定义函数不会创建闭包，只有创建/执行函数同时才创建闭包； 闭包和其函数在同一上下文中 闭包包含该作用域下的所有变量/引用地址"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-08T02:22:12.000Z"}],["meta",{"property":"article:tag","content":"闭包"}],["meta",{"property":"article:tag","content":"学习笔记"}],["meta",{"property":"article:published_time","content":"2022-09-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-08T02:22:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"闭包\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-09-09T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-08T02:22:12.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"为什么要使用闭包","slug":"为什么要使用闭包","link":"#为什么要使用闭包","children":[]},{"level":2,"title":"闭包的作用","slug":"闭包的作用","link":"#闭包的作用","children":[]},{"level":2,"title":"闭包的缺点","slug":"闭包的缺点","link":"#闭包的缺点","children":[]},{"level":2,"title":"简单实现闭包","slug":"简单实现闭包","link":"#简单实现闭包","children":[]},{"level":2,"title":"形成闭包的条件","slug":"形成闭包的条件","link":"#形成闭包的条件","children":[]},{"level":2,"title":"2023.2.7 补充","slug":"_2023-2-7-补充","link":"#_2023-2-7-补充","children":[]}],"git":{"createdTime":1662714220000,"updatedTime":1675822932000,"contributors":[{"name":"clean","email":"1518136109@qq.com","commits":5}]},"readingTime":{"minutes":4.25,"words":1276},"filePathRelative":"study/frontend/js/closure.md","localizedDate":"2022年9月9日","excerpt":"<h1> 闭包</h1>\\n<p>这是 MDN 上的描述：</p>\\n<blockquote>\\n<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>\\n</blockquote>\\n<p>即：</p>\\n<ul>\\n<li>闭包是在<code>函数创建</code>时创建的，所以<code>函数创建就会生成闭包</code>；</li>\\n<li>定义函数不会创建闭包，只有创建/执行函数同时才创建闭包；</li>\\n<li>闭包和其函数在<code>同一上下文中</code></li>\\n<li>闭包包含该作用域下的所有变量/引用地址</li>\\n</ul>","autoDesc":true}');export{e as data};
