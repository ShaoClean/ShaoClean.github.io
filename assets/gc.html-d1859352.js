const t=JSON.parse('{"key":"v-26c0ef3d","path":"/study/basic/gc.html","title":"垃圾回收算法","lang":"zh-CN","frontmatter":{"icon":"computer","date":"2023-04-14T00:00:00.000Z","category":["计算机基础","垃圾回收算法"],"tag":["学习笔记"],"description":"垃圾回收算法 标记-清除算法：标记没有被引用的对象，在下一次循环中将被标记的对象回收。 优点：不会移动对象（改变对象的引用地址），比较保守，可以非常适合配合其他保守式算法。算法简单容易实现。 缺点：容易产生内存碎片，假设被标记回收的内存为 50M，那么此时有一个超过 50M 的大对象，这一块内存是放不下的。 复制算法：当指定的一块区域（Eden 区域）内存满的时候，对两块区域（Eden 区和 From 区域）进行扫描，回收两块区域中的的垃圾对象。并将存活的对象复制到另外一块区域（To 区），此时这一块区域（To 区）被标记为 From 区。超出这一块区域（To 区）的对象放入另外的区域（老年代）。 优点：不会产生内存碎片、内存使用率高。缺点：该算法本身会占用双倍的内存空间 标记-整理算法：先标记处需要回收的对象，然后将被回收的对象往一端移动，然后直接清理掉另一端的内存。 优点：没有内存碎片缺点：整理过程中内存地址移动，效率偏低","head":[["meta",{"property":"og:url","content":"https://doc.shaoclean.top/study/basic/gc.html"}],["meta",{"property":"og:site_name","content":"clog"}],["meta",{"property":"og:title","content":"垃圾回收算法"}],["meta",{"property":"og:description","content":"垃圾回收算法 标记-清除算法：标记没有被引用的对象，在下一次循环中将被标记的对象回收。 优点：不会移动对象（改变对象的引用地址），比较保守，可以非常适合配合其他保守式算法。算法简单容易实现。 缺点：容易产生内存碎片，假设被标记回收的内存为 50M，那么此时有一个超过 50M 的大对象，这一块内存是放不下的。 复制算法：当指定的一块区域（Eden 区域）内存满的时候，对两块区域（Eden 区和 From 区域）进行扫描，回收两块区域中的的垃圾对象。并将存活的对象复制到另外一块区域（To 区），此时这一块区域（To 区）被标记为 From 区。超出这一块区域（To 区）的对象放入另外的区域（老年代）。 优点：不会产生内存碎片、内存使用率高。缺点：该算法本身会占用双倍的内存空间 标记-整理算法：先标记处需要回收的对象，然后将被回收的对象往一端移动，然后直接清理掉另一端的内存。 优点：没有内存碎片缺点：整理过程中内存地址移动，效率偏低"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-14T15:34:01.000Z"}],["meta",{"property":"article:tag","content":"学习笔记"}],["meta",{"property":"article:published_time","content":"2023-04-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-14T15:34:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"垃圾回收算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-14T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-14T15:34:01.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1681486441000,"updatedTime":1681486441000,"contributors":[{"name":"clean","email":"1518136109@qq.com","commits":1}]},"readingTime":{"minutes":1.19,"words":357},"filePathRelative":"study/basic/gc.md","localizedDate":"2023年4月14日","excerpt":"<h1> 垃圾回收算法</h1>\\n<ul>\\n<li>\\n<p>标记-清除算法：标记没有被引用的对象，在下一次循环中将被标记的对象回收。</p>\\n<p>优点：不会移动对象（改变对象的引用地址），比较保守，可以非常适合配合其他保守式算法。算法简单容易实现。</p>\\n<p>缺点：容易产生内存碎片，假设被标记回收的内存为 50M，那么此时有一个超过 50M 的大对象，这一块内存是放不下的。</p>\\n</li>\\n<li>\\n<p>复制算法：当指定的一块区域（Eden 区域）内存满的时候，对两块区域（Eden 区和 From 区域）进行扫描，回收两块区域中的的垃圾对象。并将存活的对象复制到另外一块区域（To 区），此时这一块区域（To 区）被标记为 From 区。超出这一块区域（To 区）的对象放入另外的区域（老年代）。</p>\\n<p>优点：不会产生内存碎片、内存使用率高。缺点：该算法本身会占用双倍的内存空间</p>\\n</li>\\n<li>\\n<p>标记-整理算法：先标记处需要回收的对象，然后将被回收的对象往一端移动，然后直接清理掉另一端的内存。\\n优点：没有内存碎片缺点：整理过程中内存地址移动，效率偏低</p>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
