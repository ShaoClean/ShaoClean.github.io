import{$ as e,a0 as c,a1 as o,a4 as a}from"./framework-888972eb.js";const t={},d=a('<h1 id="react-hooks" tabindex="-1"><a class="header-anchor" href="#react-hooks" aria-hidden="true">#</a> React Hooks</h1><p>常见的hooks有</p><h2 id="_1-usestate" tabindex="-1"><a class="header-anchor" href="#_1-usestate" aria-hidden="true">#</a> 1.useState</h2><h2 id="_2-useeffect" tabindex="-1"><a class="header-anchor" href="#_2-useeffect" aria-hidden="true">#</a> 2.useEffect</h2><p>该hook接受两个参数：</p><ul><li>setup（回调函数）</li><li>dependencies（依赖数组） 可选</li></ul><p>组件会在初次渲染并执行完组件中的代码时最后调用<code>useEffect</code>中的<code>setup</code>函数。</p><p>如果该回调返回了一个函数，那么这个返回的函数会在该组件销毁的时候调用</p><p>其依赖的数据发生变化时，也就是<code>dependencie</code>数组中的数据发生变化时，<code>setup</code>函数会再一次触发。</p><p><strong>如果组件重新进行了渲染</strong></p><p>此时，如果<code>setup</code>函数中有返回一个函数（官方说法叫cleanup函数，cleanup函数中的代码叫clean code）。那么在重新渲染的时候：</p><p>1.先执行组件中的同步代码</p><p>2.然后执行cleanup函数</p><p>3.然后才是执行setup函数</p><p>而且<code>cleanup</code>函数中的<code>props</code>和<code>state</code>都是旧的。</p><h2 id="_3-useref" tabindex="-1"><a class="header-anchor" href="#_3-useref" aria-hidden="true">#</a> 3.useRef</h2><p>引用一个不需要被渲染的值</p><p><strong>参数：</strong></p><p>可以是任何类型的数据。但是初始化过后，这个参数就将会被忽视。也就是说，重新渲染组件的时候，就不会重复创建这个值。</p><p><strong>返回值：</strong></p><p>返回一个对象，对象中只有一个<code>current</code>属性。这个属性的值不会因为re-render而重复创建。</p><p>如果将ref对象作为ref属性传递给JSX节点，current会返回一个dom元素（用法和vue3中的ref类似，传入的参数都会被忽略。只是在获取dom元素的时候有区别，v3用的是<code>.value</code>，react用的是<code>.current</code>）</p><ol start="4"><li>useContext</li><li>useCallback</li></ol>',23),r=[d];function s(p,n){return c(),o("div",null,r)}const i=e(t,[["render",s],["__file","ReactHooks.html.vue"]]);export{i as default};
