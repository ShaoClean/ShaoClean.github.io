const e=JSON.parse('{"key":"v-1b9f0d11","path":"/study/frontend/react/ReactExtends.html","title":"React 拓展","lang":"zh-CN","frontmatter":{"icon":"react","date":"2022-06-24T00:00:00.000Z","sticky":7,"star":8,"category":["前端","React"],"tag":["ReactExtends","学习笔记"],"description":"React 拓展 1. setState setState 更新状态的 2 种写法 (1). setState(stateChange, [callback])------对象式的setState 1.stateChange为状态改变对象(该对象可以体现出状态的更改) 2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 (2). setState(updater, [callback])------函数式的setState 1.updater为返回stateChange对象的函数。 2.updater可以接收到state和props。 4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 总结: 1.对象式的setState是函数式的setState的简写方式(语法糖) 2.使用原则： (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式 (2).如果新状态依赖于原状态 ===&gt; 使用函数方式 (3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取","head":[["meta",{"property":"og:url","content":"https://doc.shaoclean.top/study/frontend/react/ReactExtends.html"}],["meta",{"property":"og:site_name","content":"clog"}],["meta",{"property":"og:title","content":"React 拓展"}],["meta",{"property":"og:description","content":"React 拓展 1. setState setState 更新状态的 2 种写法 (1). setState(stateChange, [callback])------对象式的setState 1.stateChange为状态改变对象(该对象可以体现出状态的更改) 2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 (2). setState(updater, [callback])------函数式的setState 1.updater为返回stateChange对象的函数。 2.updater可以接收到state和props。 4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 总结: 1.对象式的setState是函数式的setState的简写方式(语法糖) 2.使用原则： (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式 (2).如果新状态依赖于原状态 ===&gt; 使用函数方式 (3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-01T09:19:50.000Z"}],["meta",{"property":"article:tag","content":"ReactExtends"}],["meta",{"property":"article:tag","content":"学习笔记"}],["meta",{"property":"article:published_time","content":"2022-06-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-01T09:19:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 拓展\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-24T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-01T09:19:50.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. setState","slug":"_1-setstate","link":"#_1-setstate","children":[{"level":3,"title":"setState 更新状态的 2 种写法","slug":"setstate-更新状态的-2-种写法","link":"#setstate-更新状态的-2-种写法","children":[]}]},{"level":2,"title":"2. lazyLoad","slug":"_2-lazyload","link":"#_2-lazyload","children":[{"level":3,"title":"路由组件的 lazyLoad","slug":"路由组件的-lazyload","link":"#路由组件的-lazyload","children":[]}]},{"level":2,"title":"3. Hooks","slug":"_3-hooks","link":"#_3-hooks","children":[]},{"level":2,"title":"4. Fragment","slug":"_4-fragment","link":"#_4-fragment","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]}]},{"level":2,"title":"5. Context","slug":"_5-context","link":"#_5-context","children":[{"level":3,"title":"理解","slug":"理解","link":"#理解","children":[]},{"level":3,"title":"使用","slug":"使用-1","link":"#使用-1","children":[]},{"level":3,"title":"注意","slug":"注意","link":"#注意","children":[]}]},{"level":2,"title":"6. 组件优化","slug":"_6-组件优化","link":"#_6-组件优化","children":[{"level":3,"title":"Component 的 2 个问题","slug":"component-的-2-个问题","link":"#component-的-2-个问题","children":[]},{"level":3,"title":"效率高的做法","slug":"效率高的做法","link":"#效率高的做法","children":[]},{"level":3,"title":"原因","slug":"原因","link":"#原因","children":[]},{"level":3,"title":"解决","slug":"解决","link":"#解决","children":[]}]},{"level":2,"title":"7. render props","slug":"_7-render-props","link":"#_7-render-props","children":[{"level":3,"title":"如何向组件内部动态传入带内容的结构(标签)?","slug":"如何向组件内部动态传入带内容的结构-标签","link":"#如何向组件内部动态传入带内容的结构-标签","children":[]},{"level":3,"title":"children props","slug":"children-props","link":"#children-props","children":[]},{"level":3,"title":"render props","slug":"render-props","link":"#render-props","children":[]}]},{"level":2,"title":"8. 错误边界","slug":"_8-错误边界","link":"#_8-错误边界","children":[]},{"level":2,"title":"9. 组件通信方式总结","slug":"_9-组件通信方式总结","link":"#_9-组件通信方式总结","children":[]}],"git":{"createdTime":1662451061000,"updatedTime":1675243190000,"contributors":[{"name":"clean","email":"1518136109@qq.com","commits":6}]},"readingTime":{"minutes":5.48,"words":1643},"filePathRelative":"study/frontend/react/ReactExtends.md","localizedDate":"2022年6月24日","excerpt":"<h1> React 拓展</h1>\\n<h2> 1. setState</h2>\\n<h3> setState 更新状态的 2 种写法</h3>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>(1). setState(stateChange, [callback])------对象式的setState\\n    1.stateChange为状态改变对象(该对象可以体现出状态的更改)\\n    2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用\\n\\n(2). setState(updater, [callback])------函数式的setState\\n    1.updater为返回stateChange对象的函数。\\n    2.updater可以接收到state和props。\\n    4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。\\n总结:\\n1.对象式的setState是函数式的setState的简写方式(语法糖)\\n2.使用原则：\\n        (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式\\n        (2).如果新状态依赖于原状态 ===&gt; 使用函数方式\\n        (3).如果需要在setState()执行后获取最新的状态数据,\\n            要在第二个callback函数中读取\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
